스프링 핵심원리 - 기본편 2일차
==========
인터페이스에 대한 구현체가 하나만 붙으면 보통 뒤에 impl을 붙인다.

## DI 컨테이너(구현체 주입 클래스)
- 구현 객체를 의존하지 않고 인터페이스만을 의존해야 DIP(의존 역전 법칙)을 준수할 수 있음
- 애플리케이션의 전체 동작 방식을 구성하기 위해, '구현 객체를 생성'하고, 연결하는 책임을 가지는 별도의 설정(클래스)
- 생성한 객체 인스턴스의 참조(구현체)를 '생성자를 통해서 연결'해준다.

## 프레임워크 VS 라이브러리
- 내가 작성한 코드를 대신 제어하고 실행할 수 있다면 프레임워크(ex JUnit @Test 어노테이션등을 통하여 실행 방식을 프레임워크가 직접 제어함)
- 내가 작성한 코드를 직접 제어해야 한다면 라이브러리

## 객체간의 '정적' 의존과 '동적' 의존
- 간단히 코드만 보고 의존관계를 확인할 수 있는 정적인 의존
- 애플리케이션 실행 시점에 실제 생성되는 인스턴스에 연결된다면 동적인 의존 = 의존관계 주입
  - 클라이언트 코드를 변경하지 않고, 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
 
</br></br>

## 스프링 컨테이너
- BeanFactory 혹은 ApplicationContext를 스프링 컨테이너라 한다. (둘다 인터페이스)
- 스프링 컨테이너는 @Configuration이 적용된 클래스에서 @Bean이 적용된 메서드들을 스스로 등록하며 이때 적용된 메서드들을 '스프링 빈'이라 한다.
-  스프링 빈에서 반환된 인스턴스는 빈 객체로 등록됨
-  스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져잇지만, 자바는 생성자를 호출하면서 의존관계 주입도 같이 처리된다.
- DI컨테이너를 직접 호출하지 않고 스프링 컨테이너를 사용하여 DI를 적용할 수 있음

</br></br>

## BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- ApplicationContext는 BeanFactory의 자식이므로 모든 기능을 상속받아서 사용할 수 있다.

## ApplicationContext
- getBeanDefinitionNames(): 스프링에 등록된 모든 빈 이름을 조회한다.
- getBean(): 빈 이름으로 빈 객체(매서드)를 조회한다.
  - 빈 조회의 대원칙: 부모 타입을 조회하면, 자식타입도 같이 끌려온다
- getRole(): 빈 정체성을 조회한다.
  - ROLE_APPLICATION: 일반적으로 사용자가 정의한 빈
  - ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하기 위하여 자체적으로 정의한 빈
- ApplicationContext가 상속받는 기능들(인터페이스)
  - MessegeSource: 지역에 따라 맞춤 언어 지원
  - EnviormentCapable: 로컬, 개발, 운영등 각 환경별로 다른 환경변수를 적용해줌
  - ApplicationEventPublisher: 애플리케이션의 이벤트를 발행하고 구독하는 모델을 편리하게 관리할 수 있도록 지원
  - ResourceOrder: 파일, 클래스경로, 외부 등에서 리소스를 편리하게 조회
